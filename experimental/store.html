<html>
<body>
<script>

'use strict';

var Store = {};
(function(exports) {
var nodes = [];
var currentTransaction = null;

function makeNode(parents, updateFunc) {
	let handlers = [];
	let initial = update();

	function update() {
		let parentValues = parents.map(parent => parent._values);
		if (parentValues.every(values => !!values)) {
			let values = updateFunc(parentValues);
		 	handlers.forEach(handler => handler.apply(null, values));
		 	return values;
		}
	}

	let node = {
		_values: initial,
		_parents: parents,

		_update: function() {
			node._values = update();
		},

		bind: function(handler) {
			handlers.push(handler);
			if (node._values) {
				handler.apply(null, node._values);
			}
		},

		derive: function(func) {
			return makeDerive(node, func);
		},
		filter: function(func) {
			return makeFilter(node, func);
		}
	};

	nodes.push(node);

	return node;
}

function makeDerive(parent, func) {
	return makeNode([parent], function deriveUpdate() {
		return [func.apply(null, parent._values)];
	});
}

function makeFilter(parent, func) {
	return makeNode([parent], function filterUpdate() {
		if (func.apply(null, parent._values)) {
			return parent._values;
		}
	});
}

exports.merge = function(parents) {
	if (!Array.isArray(parents)) {
		parents = Array.prototype.slice.call(arguments);
	}

	return makeNode(parents, function mergeUpdate() {
		let parentValues = parents.map(parent => parent._values);
		return parentValues.reduce((memo, next) => memo.concat(next));
	});
};

exports.dependent = function(parents, func) {
	return exports.merge(parents).derive(func);
};

exports.state = function(value) {
	let result = makeNode([], function updateState() {
		return [value];
	});
	result.set = function(newValue) {
		value = newValue;
		result._update([]);
		currentTransaction(result);
	};
	result.update = function(pattern) {
		for (let key in pattern) {
			value[key] = pattern[key];
		}
		result._update([]);

		currentTransaction(result);
	};
	return result;
};

function propagate(changedStates) {
	let hot = changedStates;
	let available = new Set(changedStates);
	let unknown = nodes.filter(node => !hot.has(node));

	let active = true;
	while (active) {
		active = false;
		for (let i = unknown.length - 1; i >= 0; i--) {
			let node = unknown[i];

			let parents = node._parents;

			let nodeAvailable = parents.every(parent => available.has(parent));
			let nodeHot = parents.some(parent => hot.has(parent));

			if (nodeAvailable) {
				if (nodeHot) {
					node._update();
					hot.add(node);
				}
				available.add(node);

				unknown.splice(i, 1);
				active = true;
			}
		}
	}
}

exports.transaction = function(scope) {
	if (currentTransaction) {
		return scope();
	}

	let changedStates = new Set();
	currentTransaction = function(node) {
		changedStates.add(node);
	};
	scope();
	currentTransaction = null;

	propagate(changedStates);
};

})(Store);

let a = Store.state(1);
let b = Store.state(2);
let c = Store.state(3);
let d = a.derive(x => 2 * x);
let e = Store.dependent(
	[
		Store.dependent([a, b], (a, b) => a + b),
		Store.dependent([b, c], (b, c) => b + c)
	],
	(x, y) => x + y
);
let f = Store.merge(a, b).filter((a, b) => a + b > 5);

a.bind(x => console.log('A:', x));
b.bind(x => console.log('B:', x));
c.bind(x => console.log('C:', x));
d.bind(x => console.log('D:', x));
e.bind(function() { console.log('E:', Array.prototype.slice.call(arguments)); });
f.bind(function() { console.log('F:', Array.prototype.slice.call(arguments)); });

Store.transaction(function() {
	a.set(2);
	b.set(4);
	c.set(6);
});

Store.transaction(function() {
	a.set(5);
});

</script>
</body>
</html>