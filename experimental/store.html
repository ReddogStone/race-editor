<html>
<body>
<script>

'use strict';

var Store = {};
(function(exports) {
var nodes = [];
var currentTransaction = null;

function makeNode(parents, updateFunc) {
	let handlers = [];
	let initial = update();

	function update() {
		let parentValues = parents.map(parent => parent._values);
		if (parentValues.every(values => !!values)) {
			let values = updateFunc(parentValues);
		 	handlers.forEach(handler => handler.apply(null, values));
		 	return values;
		}
	}

	let node = {
		_values: initial,
		_parents: parents,

		_update: function() {
			node._values = update();
		},

		bind: function(handler) {
			handlers.push(handler);
			if (node._values) {
				handler.apply(null, node._values);
			}
		},

		derive: function(func) {
			return derive(node, func);
		}
	};

	nodes.push(node);

	return node;
}

function derive(parent, func) {
	var cached;
	return makeNode([parent], function deriveUpdate() {
		return [func.apply(null, parent._values)];
	});
}

exports.merge = function(parents) {
	if (!Array.isArray(parents)) {
		parents = Array.prototype.slice.call(arguments);
	}

	return makeNode(parents, function mergeUpdate() {
		let parentValues = parents.map(parent => parent._values);
		return parentValues.reduce((memo, next) => memo.concat(next));
	});
}

exports.state = function(value) {
	let result = makeNode([], function updateState() {
		return [value];
	});
	result.set = function(newValue) {
		value = newValue;
		result._update([]);
		currentTransaction(result);
	};
	result.update = function(pattern) {
		for (let key in pattern) {
			value[key] = pattern[key];
		}
		result._update([]);

		currentTransaction(result);
	};
	return result;
};

// function Node(initial, parents) {
// 	this._values = initial;
// 	this._parents = parents;

// 	this._handlers = [];
// }

// Node.prototype._get = function(parentValues) {
// 	return this._values;
// };
// Node.prototype._update = function() {
// 	throw new Error('_update not implemented');
// };

// Node.prototype._notify = function(values) {
// 	handlers.forEach(handler => handler.apply(null, values) );
// };

// Node.prototype.on = function(handler) {
// 	handlers.push(handler);	
// };
// Node.prototype.derive = function(func) {
// 	return new Derive(this._values, this);
// };

// function State(initial) {
// 	Node.call(this, [initial], []);
// }

// State.prototype.set = function(value) {
// 	this._values = [value];
// 	currentTransaction(this, this._values);
// };
// State.prototype.update = function(pattern) {
// 	let value = this._values[0];
// 	for (let key in pattern) {
// 		value[key] = pattern[key];
// 	}
// 	currentTransaction(this, [value]);
// };

// function Derive(initial, parent, func) {
// 	Node.call(this, func.apply(null, initial), [parent]);
// 	this._func = func;
// }

// Derive.prototype._update = function() {
// 	this._values = this._func.apply(null, this._parents[0]._values);
// };

// function Merge(parents) {
// 	Node.call(this, initial, parents);
// 	this._func = func;
// }

// Derive.prototype._update = function() {
// 	this._values = this._func.apply(null, this._parents[0]._values);
// };

function propagate(changedStates) {
	let hot = changedStates;
	let available = new Set(changedStates);
	let unknown = nodes.filter(node => !hot.has(node));

	let active = true;
	while (active) {
		active = false;
		for (let i = unknown.length - 1; i >= 0; i--) {
			let node = unknown[i];

			let parents = node._parents;

			let nodeAvailable = parents.every(parent => available.has(parent));
			let nodeHot = parents.some(parent => hot.has(parent));

			if (nodeAvailable) {
				if (nodeHot) {
					node._update();
					hot.add(node);
				}
				available.add(node);

				unknown.splice(i, 1);
				active = true;
			}
		}
	}
}

exports.transaction = function(scope) {
	if (currentTransaction) {
		return scope();
	}

	let changedStates = new Set();
	currentTransaction = function(node) {
		changedStates.add(node);
	};
	scope();
	currentTransaction = null;

	propagate(changedStates);
};

})(Store);

let a = Store.state(1);
let b = Store.state(2);
let c = Store.state(3);
let d = a.derive(x => 2 * x);
let e = Store.merge(Store.merge(a, b).derive((a, b) => a + b), Store.merge(b, c).derive((b, c) => b + c)).derive((x, y) => x + y);

a.bind(x => console.log('A:', x));
b.bind(x => console.log('B:', x));
c.bind(x => console.log('C:', x));
d.bind(x => console.log('D:', x));
e.bind(function() { console.log('E:', Array.prototype.slice.call(arguments)); });

Store.transaction(function() {
	a.set(2);
	b.set(4);
	c.set(6);
});

Store.transaction(function() {
	a.set(5);
});

</script>
</body>
</html>